package services;

import static akka.pattern.Patterns.ask;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Stream;
import akka.actor.typed.Behavior;
import akka.actor.typed.PostStop;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
import akka.actor.*;
import javax.inject.Inject;

import play.libs.ws.*;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;

import akka.actor.AbstractLoggingActor;
import akka.actor.ActorRef;
import akka.actor.Props;
import dao.FreelancerResult;
import dao.Project;
import dao.ProjectResponse;
import scala.compat.java8.FutureConverters;


/** This actor class is used by controller as a layer to get projects and calculate flesch index
 * @author Vaibhav Verma
 * @version 2.0
 * @since 1.0
*/
public class FleschActorService extends AbstractLoggingActor {
	 public interface Command {}
	 ObjectMapper mapper;
	 private final WSClient ws;
	 
	 @Inject
	    public FleschActorService(WSClient ws) {
	        this.ws = ws;
	        mapper = new ObjectMapper();
	        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
	    }
	 
	 public static class fleschActorClass {
	        final private String keyWord;

	        public fleschActorClass(String keyWord) {
	            this.keyWord = keyWord;
	        }
	    }
	 /** This method is used to convert the latest active projects where the data is processed by streams to useful data for the frontent
		 * @author Vaibhav Verma
		 * @param x is the arraylist of latest active projects that came from websocket call
		 * @return it returns a list of active projects with all details used by the front end generated by streams.
		 * @version 2.0
		 * @since 1.0
		*/
	    public static List<ProjectResponse> convertProjects(ArrayList<Project> x) {
			Stream<ProjectResponse> projRes = x.stream()
					.map(p -> new ProjectResponse(p.getOwner_id(), p.getTime_submitted(),p.getTitle(), p.getProject_type(), FreeLancelotService.convertJobDetails(p.getJobs()),p.getSeo_url(), p.getPreview_description()));
			return FreeLancelotService.calculateFlesch(projRes);
		
}
	    @Override
		public Receive createReceive() {
			return receiveBuilder()
	                .match(FleschActorService.fleschActorClass.class, this::fleschProjects)
	                .build();
		}
		
		public static Props props(WSClient ws) {
	        return Props.create(FleschActorService.class, ws);
	    }   
		
		
		/** This method is used to used to call the second layer which calls the API to fetch data and it manipulates the incoming data
		 * @author Vaibhav Verma
		 * @param obj is the fleschActorClass which contains the keyword
		 * @version 2.0
		 * @since 1.0
		*/
		public void fleschProjects(fleschActorClass obj) {
			final ActorRef senderRef = sender();
		    final ActorRef superVisorActor = context().actorOf(ServiceActorSupervisor.props(ws));

		    ((CompletableFuture) FutureConverters.toJava(
		            ask(superVisorActor, new FreeLancelotActorService.projectSearchActorClass(obj.keyWord), 5000)))
		            .thenApplyAsync(json -> {
		            	List<ProjectResponse> projects = convertProjects((ArrayList<Project>) json);
		                return projects;
		            }).thenAccept(response -> senderRef.tell((List<ProjectResponse>) response, self()));
		   
		}
	    
	    
}
